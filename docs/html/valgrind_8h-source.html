<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>lighttpd-cpp: include/lighttpd/valgrind/valgrind.h Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.8 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
    </ul>
  </div>
<h1>include/lighttpd/valgrind/valgrind.h</h1><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/* -*- c -*-</span>
<a name="l00002"></a>00002 <span class="comment">   ----------------------------------------------------------------</span>
<a name="l00003"></a>00003 <span class="comment"></span>
<a name="l00004"></a>00004 <span class="comment">   Notice that the following BSD-style license applies to this one</span>
<a name="l00005"></a>00005 <span class="comment">   file (valgrind.h) only.  The entire rest of Valgrind is licensed</span>
<a name="l00006"></a>00006 <span class="comment">   under the terms of the GNU General Public License, version 2.  See</span>
<a name="l00007"></a>00007 <span class="comment">   the COPYING file in the source distribution for details.</span>
<a name="l00008"></a>00008 <span class="comment"></span>
<a name="l00009"></a>00009 <span class="comment">   ----------------------------------------------------------------</span>
<a name="l00010"></a>00010 <span class="comment"></span>
<a name="l00011"></a>00011 <span class="comment">   This file is part of Valgrind, a dynamic binary instrumentation</span>
<a name="l00012"></a>00012 <span class="comment">   framework.</span>
<a name="l00013"></a>00013 <span class="comment"></span>
<a name="l00014"></a>00014 <span class="comment">   Copyright (C) 2000-2005 Julian Seward.  All rights reserved.</span>
<a name="l00015"></a>00015 <span class="comment"></span>
<a name="l00016"></a>00016 <span class="comment">   Redistribution and use in source and binary forms, with or without</span>
<a name="l00017"></a>00017 <span class="comment">   modification, are permitted provided that the following conditions</span>
<a name="l00018"></a>00018 <span class="comment">   are met:</span>
<a name="l00019"></a>00019 <span class="comment"></span>
<a name="l00020"></a>00020 <span class="comment">   1. Redistributions of source code must retain the above copyright</span>
<a name="l00021"></a>00021 <span class="comment">      notice, this list of conditions and the following disclaimer.</span>
<a name="l00022"></a>00022 <span class="comment"></span>
<a name="l00023"></a>00023 <span class="comment">   2. The origin of this software must not be misrepresented; you must </span>
<a name="l00024"></a>00024 <span class="comment">      not claim that you wrote the original software.  If you use this </span>
<a name="l00025"></a>00025 <span class="comment">      software in a product, an acknowledgment in the product </span>
<a name="l00026"></a>00026 <span class="comment">      documentation would be appreciated but is not required.</span>
<a name="l00027"></a>00027 <span class="comment"></span>
<a name="l00028"></a>00028 <span class="comment">   3. Altered source versions must be plainly marked as such, and must</span>
<a name="l00029"></a>00029 <span class="comment">      not be misrepresented as being the original software.</span>
<a name="l00030"></a>00030 <span class="comment"></span>
<a name="l00031"></a>00031 <span class="comment">   4. The name of the author may not be used to endorse or promote </span>
<a name="l00032"></a>00032 <span class="comment">      products derived from this software without specific prior written </span>
<a name="l00033"></a>00033 <span class="comment">      permission.</span>
<a name="l00034"></a>00034 <span class="comment"></span>
<a name="l00035"></a>00035 <span class="comment">   THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS</span>
<a name="l00036"></a>00036 <span class="comment">   OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED</span>
<a name="l00037"></a>00037 <span class="comment">   WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE</span>
<a name="l00038"></a>00038 <span class="comment">   ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY</span>
<a name="l00039"></a>00039 <span class="comment">   DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL</span>
<a name="l00040"></a>00040 <span class="comment">   DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE</span>
<a name="l00041"></a>00041 <span class="comment">   GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS</span>
<a name="l00042"></a>00042 <span class="comment">   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,</span>
<a name="l00043"></a>00043 <span class="comment">   WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING</span>
<a name="l00044"></a>00044 <span class="comment">   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS</span>
<a name="l00045"></a>00045 <span class="comment">   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
<a name="l00046"></a>00046 <span class="comment"></span>
<a name="l00047"></a>00047 <span class="comment">   ----------------------------------------------------------------</span>
<a name="l00048"></a>00048 <span class="comment"></span>
<a name="l00049"></a>00049 <span class="comment">   Notice that the above BSD-style license applies to this one file</span>
<a name="l00050"></a>00050 <span class="comment">   (valgrind.h) only.  The entire rest of Valgrind is licensed under</span>
<a name="l00051"></a>00051 <span class="comment">   the terms of the GNU General Public License, version 2.  See the</span>
<a name="l00052"></a>00052 <span class="comment">   COPYING file in the source distribution for details.</span>
<a name="l00053"></a>00053 <span class="comment"></span>
<a name="l00054"></a>00054 <span class="comment">   ---------------------------------------------------------------- </span>
<a name="l00055"></a>00055 <span class="comment">*/</span>
<a name="l00056"></a>00056 
<a name="l00057"></a>00057 
<a name="l00058"></a>00058 <span class="comment">/* This file is for inclusion into client (your!) code.</span>
<a name="l00059"></a>00059 <span class="comment"></span>
<a name="l00060"></a>00060 <span class="comment">   You can use these macros to manipulate and query Valgrind's </span>
<a name="l00061"></a>00061 <span class="comment">   execution inside your own programs.</span>
<a name="l00062"></a>00062 <span class="comment"></span>
<a name="l00063"></a>00063 <span class="comment">   The resulting executables will still run without Valgrind, just a</span>
<a name="l00064"></a>00064 <span class="comment">   little bit more slowly than they otherwise would, but otherwise</span>
<a name="l00065"></a>00065 <span class="comment">   unchanged.  When not running on valgrind, each client request</span>
<a name="l00066"></a>00066 <span class="comment">   consumes very few (eg. &lt; 10) instructions, so the resulting performance</span>
<a name="l00067"></a>00067 <span class="comment">   loss is negligible unless you plan to execute client requests</span>
<a name="l00068"></a>00068 <span class="comment">   millions of times per second.  Nevertheless, if that is still a</span>
<a name="l00069"></a>00069 <span class="comment">   problem, you can compile with the NVALGRIND symbol defined (gcc</span>
<a name="l00070"></a>00070 <span class="comment">   -DNVALGRIND) so that client requests are not even compiled in.  */</span>
<a name="l00071"></a>00071 
<a name="l00072"></a>00072 <span class="preprocessor">#ifndef __VALGRIND_H</span>
<a name="l00073"></a>00073 <span class="preprocessor"></span><span class="preprocessor">#define __VALGRIND_H</span>
<a name="l00074"></a>00074 <span class="preprocessor"></span>
<a name="l00075"></a>00075 <span class="preprocessor">#include &lt;stdarg.h&gt;</span>
<a name="l00076"></a>00076 
<a name="l00077"></a>00077 <span class="comment">/* Nb: this file might be included in a file compiled with -ansi.  So</span>
<a name="l00078"></a>00078 <span class="comment">   we can't use C++ style "//" comments nor the "asm" keyword (instead</span>
<a name="l00079"></a>00079 <span class="comment">   use "__asm__"). */</span>
<a name="l00080"></a>00080 
<a name="l00081"></a>00081 <span class="comment">/* If we're not compiling for our target architecture, don't generate</span>
<a name="l00082"></a>00082 <span class="comment">   any inline asms.  Note that in this file we're using the compiler's</span>
<a name="l00083"></a>00083 <span class="comment">   CPP symbols for identifying architectures, which are different to</span>
<a name="l00084"></a>00084 <span class="comment">   the ones we use within the rest of Valgrind. */</span>
<a name="l00085"></a>00085 <span class="preprocessor">#if !defined(__i386__) &amp;&amp; !defined(__x86_64__) &amp;&amp; !defined(__powerpc__)</span>
<a name="l00086"></a>00086 <span class="preprocessor"></span><span class="preprocessor">#  ifndef NVALGRIND</span>
<a name="l00087"></a>00087 <span class="preprocessor"></span><span class="preprocessor">#    define NVALGRIND   1</span>
<a name="l00088"></a>00088 <span class="preprocessor"></span><span class="preprocessor">#  endif  </span><span class="comment">/* NVALGRIND */</span>
<a name="l00089"></a>00089 <span class="preprocessor">#endif</span>
<a name="l00090"></a>00090 <span class="preprocessor"></span>
<a name="l00091"></a>00091 <span class="comment">/* ------------------------------------------------------------------ */</span>
<a name="l00092"></a>00092 <span class="comment">/* The architecture-specific part                                     */</span>
<a name="l00093"></a>00093 <span class="comment">/* ------------------------------------------------------------------ */</span>
<a name="l00094"></a>00094 
<a name="l00095"></a>00095 <span class="preprocessor">#ifdef NVALGRIND</span>
<a name="l00096"></a>00096 <span class="preprocessor"></span>
<a name="l00097"></a>00097 <span class="comment">/* Define NVALGRIND to completely remove the Valgrind magic sequence</span>
<a name="l00098"></a>00098 <span class="comment">   from the compiled code (analogous to NDEBUG's effects on assert()) */</span>
<a name="l00099"></a>00099 <span class="preprocessor">#define VALGRIND_MAGIC_SEQUENCE(                                        \</span>
<a name="l00100"></a>00100 <span class="preprocessor">        _zzq_rlval, _zzq_default, _zzq_request,                         \</span>
<a name="l00101"></a>00101 <span class="preprocessor">        _zzq_arg1, _zzq_arg2, _zzq_arg3, _zzq_arg4)                     \</span>
<a name="l00102"></a>00102 <span class="preprocessor">   {                                                                    \</span>
<a name="l00103"></a>00103 <span class="preprocessor">      (_zzq_rlval) = (_zzq_default);                                    \</span>
<a name="l00104"></a>00104 <span class="preprocessor">   }</span>
<a name="l00105"></a>00105 <span class="preprocessor"></span>
<a name="l00106"></a>00106 <span class="preprocessor">#else  </span><span class="comment">/* NVALGRIND */</span>
<a name="l00107"></a>00107 
<a name="l00108"></a>00108 <span class="comment">/* The following defines the magic code sequences which the JITter spots and</span>
<a name="l00109"></a>00109 <span class="comment">   handles magically.  Don't look too closely at them; they will rot</span>
<a name="l00110"></a>00110 <span class="comment">   your brain.  We must ensure that the default value gets put in the return</span>
<a name="l00111"></a>00111 <span class="comment">   slot, so that everything works when this is executed not under Valgrind.</span>
<a name="l00112"></a>00112 <span class="comment">   Args are passed in a memory block, and so there's no intrinsic limit to</span>
<a name="l00113"></a>00113 <span class="comment">   the number that could be passed, but it's currently four.</span>
<a name="l00114"></a>00114 <span class="comment">   </span>
<a name="l00115"></a>00115 <span class="comment">   The macro args are: </span>
<a name="l00116"></a>00116 <span class="comment">      _zzq_rlval    result lvalue</span>
<a name="l00117"></a>00117 <span class="comment">      _zzq_default  default value (result returned when running on real CPU)</span>
<a name="l00118"></a>00118 <span class="comment">      _zzq_request  request code</span>
<a name="l00119"></a>00119 <span class="comment">      _zzq_arg1..4  request params</span>
<a name="l00120"></a>00120 <span class="comment"></span>
<a name="l00121"></a>00121 <span class="comment">   Nb: we put the assembly code sequences for all architectures in this one</span>
<a name="l00122"></a>00122 <span class="comment">   file.  This is because this file must be stand-alone, and we don't want</span>
<a name="l00123"></a>00123 <span class="comment">   to have multiple files.</span>
<a name="l00124"></a>00124 <span class="comment">*/</span>
<a name="l00125"></a>00125 
<a name="l00126"></a>00126 <span class="preprocessor">#ifdef __x86_64__</span>
<a name="l00127"></a>00127 <span class="preprocessor"></span><span class="preprocessor">#define VALGRIND_MAGIC_SEQUENCE(                                \</span>
<a name="l00128"></a>00128 <span class="preprocessor">        _zzq_rlval, _zzq_default, _zzq_request,                 \</span>
<a name="l00129"></a>00129 <span class="preprocessor">        _zzq_arg1, _zzq_arg2, _zzq_arg3, _zzq_arg4)             \</span>
<a name="l00130"></a>00130 <span class="preprocessor">                                                                \</span>
<a name="l00131"></a>00131 <span class="preprocessor">  { volatile unsigned long long _zzq_args[5];                   \</span>
<a name="l00132"></a>00132 <span class="preprocessor">    _zzq_args[0] = (volatile unsigned long long)(_zzq_request); \</span>
<a name="l00133"></a>00133 <span class="preprocessor">    _zzq_args[1] = (volatile unsigned long long)(_zzq_arg1);    \</span>
<a name="l00134"></a>00134 <span class="preprocessor">    _zzq_args[2] = (volatile unsigned long long)(_zzq_arg2);    \</span>
<a name="l00135"></a>00135 <span class="preprocessor">    _zzq_args[3] = (volatile unsigned long long)(_zzq_arg3);    \</span>
<a name="l00136"></a>00136 <span class="preprocessor">    _zzq_args[4] = (volatile unsigned long long)(_zzq_arg4);    \</span>
<a name="l00137"></a>00137 <span class="preprocessor">    __asm__ volatile("roll $29, %%eax ; roll $3, %%eax\n\t"     \</span>
<a name="l00138"></a>00138 <span class="preprocessor">                     "rorl $27, %%eax ; rorl $5, %%eax\n\t"     \</span>
<a name="l00139"></a>00139 <span class="preprocessor">                     "roll $13, %%eax ; roll $19, %%eax"                \</span>
<a name="l00140"></a>00140 <span class="preprocessor">                     : "=d" (_zzq_rlval)                                \</span>
<a name="l00141"></a>00141 <span class="preprocessor">                     : "a" (&amp;_zzq_args[0]), "0" (_zzq_default)  \</span>
<a name="l00142"></a>00142 <span class="preprocessor">                     : "cc", "memory"                           \</span>
<a name="l00143"></a>00143 <span class="preprocessor">                    );                                          \</span>
<a name="l00144"></a>00144 <span class="preprocessor">  }</span>
<a name="l00145"></a>00145 <span class="preprocessor"></span><span class="preprocessor">#endif  </span><span class="comment">/* __x86_64__ */</span>
<a name="l00146"></a>00146 
<a name="l00147"></a>00147 <span class="preprocessor">#ifdef __i386__</span>
<a name="l00148"></a>00148 <span class="preprocessor"></span><span class="preprocessor">#define VALGRIND_MAGIC_SEQUENCE(                                \</span>
<a name="l00149"></a>00149 <span class="preprocessor">        _zzq_rlval, _zzq_default, _zzq_request,                 \</span>
<a name="l00150"></a>00150 <span class="preprocessor">        _zzq_arg1, _zzq_arg2, _zzq_arg3, _zzq_arg4)             \</span>
<a name="l00151"></a>00151 <span class="preprocessor">                                                                \</span>
<a name="l00152"></a>00152 <span class="preprocessor">  { unsigned int _zzq_args[5];                                  \</span>
<a name="l00153"></a>00153 <span class="preprocessor">    _zzq_args[0] = (unsigned int)(_zzq_request);                \</span>
<a name="l00154"></a>00154 <span class="preprocessor">    _zzq_args[1] = (unsigned int)(_zzq_arg1);                   \</span>
<a name="l00155"></a>00155 <span class="preprocessor">    _zzq_args[2] = (unsigned int)(_zzq_arg2);                   \</span>
<a name="l00156"></a>00156 <span class="preprocessor">    _zzq_args[3] = (unsigned int)(_zzq_arg3);                   \</span>
<a name="l00157"></a>00157 <span class="preprocessor">    _zzq_args[4] = (unsigned int)(_zzq_arg4);                   \</span>
<a name="l00158"></a>00158 <span class="preprocessor">    __asm__ volatile("roll $29, %%eax ; roll $3, %%eax\n\t"     \</span>
<a name="l00159"></a>00159 <span class="preprocessor">                     "rorl $27, %%eax ; rorl $5, %%eax\n\t"     \</span>
<a name="l00160"></a>00160 <span class="preprocessor">                     "roll $13, %%eax ; roll $19, %%eax"        \</span>
<a name="l00161"></a>00161 <span class="preprocessor">                     : "=d" (_zzq_rlval)                        \</span>
<a name="l00162"></a>00162 <span class="preprocessor">                     : "a" (&amp;_zzq_args[0]), "0" (_zzq_default)  \</span>
<a name="l00163"></a>00163 <span class="preprocessor">                     : "cc", "memory"                           \</span>
<a name="l00164"></a>00164 <span class="preprocessor">                    );                                          \</span>
<a name="l00165"></a>00165 <span class="preprocessor">  }</span>
<a name="l00166"></a>00166 <span class="preprocessor"></span><span class="preprocessor">#endif  </span><span class="comment">/* __i386__ */</span>
<a name="l00167"></a>00167 
<a name="l00168"></a>00168 <span class="preprocessor">#ifdef __powerpc__</span>
<a name="l00169"></a>00169 <span class="preprocessor"></span><span class="preprocessor">#define VALGRIND_MAGIC_SEQUENCE(                                        \</span>
<a name="l00170"></a>00170 <span class="preprocessor">        _zzq_rlval, _zzq_default, _zzq_request,                         \</span>
<a name="l00171"></a>00171 <span class="preprocessor">        _zzq_arg1, _zzq_arg2, _zzq_arg3, _zzq_arg4)                     \</span>
<a name="l00172"></a>00172 <span class="preprocessor">                                                                        \</span>
<a name="l00173"></a>00173 <span class="preprocessor">  { volatile unsigned int _zzq_args[5];                                 \</span>
<a name="l00174"></a>00174 <span class="preprocessor">    register unsigned int _zzq_tmp __asm__("r3");                       \</span>
<a name="l00175"></a>00175 <span class="preprocessor">    register volatile unsigned int *_zzq_ptr __asm__("r4");             \</span>
<a name="l00176"></a>00176 <span class="preprocessor">    _zzq_args[0] = (volatile unsigned int)(_zzq_request);               \</span>
<a name="l00177"></a>00177 <span class="preprocessor">    _zzq_args[1] = (volatile unsigned int)(_zzq_arg1);                  \</span>
<a name="l00178"></a>00178 <span class="preprocessor">    _zzq_args[2] = (volatile unsigned int)(_zzq_arg2);                  \</span>
<a name="l00179"></a>00179 <span class="preprocessor">    _zzq_args[3] = (volatile unsigned int)(_zzq_arg3);                  \</span>
<a name="l00180"></a>00180 <span class="preprocessor">    _zzq_args[4] = (volatile unsigned int)(_zzq_arg4);                  \</span>
<a name="l00181"></a>00181 <span class="preprocessor">    _zzq_ptr = _zzq_args;                                               \</span>
<a name="l00182"></a>00182 <span class="preprocessor">    __asm__ volatile("tw 0,3,27\n\t"                                    \</span>
<a name="l00183"></a>00183 <span class="preprocessor">                     "rlwinm 0,0,29,0,0\n\t"                            \</span>
<a name="l00184"></a>00184 <span class="preprocessor">                     "rlwinm 0,0,3,0,0\n\t"                             \</span>
<a name="l00185"></a>00185 <span class="preprocessor">                     "rlwinm 0,0,13,0,0\n\t"                            \</span>
<a name="l00186"></a>00186 <span class="preprocessor">                     "rlwinm 0,0,19,0,0\n\t"                            \</span>
<a name="l00187"></a>00187 <span class="preprocessor">                     "nop\n\t"                                          \</span>
<a name="l00188"></a>00188 <span class="preprocessor">                     : "=r" (_zzq_tmp)                                  \</span>
<a name="l00189"></a>00189 <span class="preprocessor">                     : "0" (_zzq_default), "r" (_zzq_ptr)               \</span>
<a name="l00190"></a>00190 <span class="preprocessor">                     : "memory");                                       \</span>
<a name="l00191"></a>00191 <span class="preprocessor">    _zzq_rlval = (__typeof__(_zzq_rlval)) _zzq_tmp;                     \</span>
<a name="l00192"></a>00192 <span class="preprocessor">  }</span>
<a name="l00193"></a>00193 <span class="preprocessor"></span><span class="preprocessor">#endif   </span><span class="comment">/* __powerpc__ */</span>
<a name="l00194"></a>00194 
<a name="l00195"></a>00195 <span class="comment">/* Insert assembly code for other architectures here... */</span>
<a name="l00196"></a>00196 
<a name="l00197"></a>00197 <span class="preprocessor">#endif </span><span class="comment">/* NVALGRIND */</span>
<a name="l00198"></a>00198 
<a name="l00199"></a>00199 
<a name="l00200"></a>00200 <span class="comment">/* ------------------------------------------------------------------ */</span>
<a name="l00201"></a>00201 <span class="comment">/* The architecture-independent part                                  */</span>
<a name="l00202"></a>00202 <span class="comment">/* ------------------------------------------------------------------ */</span>
<a name="l00203"></a>00203 
<a name="l00204"></a>00204 <span class="comment">/* Some request codes.  There are many more of these, but most are not</span>
<a name="l00205"></a>00205 <span class="comment">   exposed to end-user view.  These are the public ones, all of the</span>
<a name="l00206"></a>00206 <span class="comment">   form 0x1000 + small_number.</span>
<a name="l00207"></a>00207 <span class="comment"></span>
<a name="l00208"></a>00208 <span class="comment">   Core ones are in the range 0x00000000--0x0000ffff.  The non-public ones</span>
<a name="l00209"></a>00209 <span class="comment">   start at 0x2000.</span>
<a name="l00210"></a>00210 <span class="comment">*/</span>
<a name="l00211"></a>00211 
<a name="l00212"></a>00212 <span class="comment">/* These macros are used by tools -- they must be public, but don't embed them</span>
<a name="l00213"></a>00213 <span class="comment"> * into other programs. */</span>
<a name="l00214"></a>00214 <span class="preprocessor">#define VG_USERREQ_TOOL_BASE(a,b) \</span>
<a name="l00215"></a>00215 <span class="preprocessor">   ((unsigned int)(((a)&amp;0xff) &lt;&lt; 24 | ((b)&amp;0xff) &lt;&lt; 16))</span>
<a name="l00216"></a>00216 <span class="preprocessor"></span><span class="preprocessor">#define VG_IS_TOOL_USERREQ(a, b, v) \</span>
<a name="l00217"></a>00217 <span class="preprocessor">   (VG_USERREQ_TOOL_BASE(a,b) == ((v) &amp; 0xffff0000))</span>
<a name="l00218"></a>00218 <span class="preprocessor"></span>
<a name="l00219"></a>00219 <span class="keyword">typedef</span>
<a name="l00220"></a>00220    <span class="keyword">enum</span> { VG_USERREQ__RUNNING_ON_VALGRIND  = 0x1001,
<a name="l00221"></a>00221           VG_USERREQ__DISCARD_TRANSLATIONS = 0x1002,
<a name="l00222"></a>00222 
<a name="l00223"></a>00223           <span class="comment">/* These allow any function to be called from the</span>
<a name="l00224"></a>00224 <span class="comment">             simulated CPU but run on the real CPU.</span>
<a name="l00225"></a>00225 <span class="comment">             Nb: the first arg passed to the function is always the ThreadId of</span>
<a name="l00226"></a>00226 <span class="comment">             the running thread!  So CLIENT_CALL0 actually requires a 1 arg</span>
<a name="l00227"></a>00227 <span class="comment">             function, etc. */</span>
<a name="l00228"></a>00228           VG_USERREQ__CLIENT_CALL0 = 0x1101,
<a name="l00229"></a>00229           VG_USERREQ__CLIENT_CALL1 = 0x1102,
<a name="l00230"></a>00230           VG_USERREQ__CLIENT_CALL2 = 0x1103,
<a name="l00231"></a>00231           VG_USERREQ__CLIENT_CALL3 = 0x1104,
<a name="l00232"></a>00232 
<a name="l00233"></a>00233           <span class="comment">/* Can be useful in regression testing suites -- eg. can send</span>
<a name="l00234"></a>00234 <span class="comment">             Valgrind's output to /dev/null and still count errors. */</span>
<a name="l00235"></a>00235           VG_USERREQ__COUNT_ERRORS = 0x1201,
<a name="l00236"></a>00236 
<a name="l00237"></a>00237           <span class="comment">/* These are useful and can be interpreted by any tool that tracks</span>
<a name="l00238"></a>00238 <span class="comment">             malloc() et al, by using vg_replace_malloc.c. */</span>
<a name="l00239"></a>00239           VG_USERREQ__MALLOCLIKE_BLOCK = 0x1301,
<a name="l00240"></a>00240           VG_USERREQ__FREELIKE_BLOCK   = 0x1302,
<a name="l00241"></a>00241           <span class="comment">/* Memory pool support. */</span>
<a name="l00242"></a>00242           VG_USERREQ__CREATE_MEMPOOL   = 0x1303,
<a name="l00243"></a>00243           VG_USERREQ__DESTROY_MEMPOOL  = 0x1304,
<a name="l00244"></a>00244           VG_USERREQ__MEMPOOL_ALLOC    = 0x1305,
<a name="l00245"></a>00245           VG_USERREQ__MEMPOOL_FREE     = 0x1306,
<a name="l00246"></a>00246 
<a name="l00247"></a>00247           <span class="comment">/* Allow printfs to valgrind log. */</span>
<a name="l00248"></a>00248           VG_USERREQ__PRINTF           = 0x1401,
<a name="l00249"></a>00249           VG_USERREQ__PRINTF_BACKTRACE = 0x1402,
<a name="l00250"></a>00250 
<a name="l00251"></a>00251           <span class="comment">/* Stack support. */</span>
<a name="l00252"></a>00252           VG_USERREQ__STACK_REGISTER   = 0x1501,
<a name="l00253"></a>00253           VG_USERREQ__STACK_DEREGISTER = 0x1502,
<a name="l00254"></a>00254           VG_USERREQ__STACK_CHANGE     = 0x1503,
<a name="l00255"></a>00255    } Vg_ClientRequest;
<a name="l00256"></a>00256 
<a name="l00257"></a>00257 <span class="preprocessor">#ifndef __GNUC__</span>
<a name="l00258"></a>00258 <span class="preprocessor"></span><span class="preprocessor">#define __extension__</span>
<a name="l00259"></a>00259 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00260"></a>00260 <span class="preprocessor"></span>
<a name="l00261"></a>00261 <span class="comment">/* Returns the number of Valgrinds this code is running under.  That is,</span>
<a name="l00262"></a>00262 <span class="comment">   0 if running natively, 1 if running under Valgrind, 2 if running under</span>
<a name="l00263"></a>00263 <span class="comment">   Valgrind which is running under another Valgrind, etc. */</span>
<a name="l00264"></a>00264 <span class="preprocessor">#define RUNNING_ON_VALGRIND  __extension__                         \</span>
<a name="l00265"></a>00265 <span class="preprocessor">   ({unsigned int _qzz_res;                                        \</span>
<a name="l00266"></a>00266 <span class="preprocessor">    VALGRIND_MAGIC_SEQUENCE(_qzz_res, 0 </span><span class="comment">/* returned if not */</span>,     \
<a name="l00267"></a>00267                             VG_USERREQ__RUNNING_ON_VALGRIND,       \
<a name="l00268"></a>00268                             0, 0, 0, 0);                           \
<a name="l00269"></a>00269     _qzz_res;                                                      \
<a name="l00270"></a>00270    })
<a name="l00271"></a>00271 
<a name="l00272"></a>00272 
<a name="l00273"></a>00273 <span class="comment">/* Discard translation of code in the range [_qzz_addr .. _qzz_addr +</span>
<a name="l00274"></a>00274 <span class="comment">   _qzz_len - 1].  Useful if you are debugging a JITter or some such,</span>
<a name="l00275"></a>00275 <span class="comment">   since it provides a way to make sure valgrind will retranslate the</span>
<a name="l00276"></a>00276 <span class="comment">   invalidated area.  Returns no value. */</span>
<a name="l00277"></a>00277 <span class="preprocessor">#define VALGRIND_DISCARD_TRANSLATIONS(_qzz_addr,_qzz_len)          \</span>
<a name="l00278"></a>00278 <span class="preprocessor">   {unsigned int _qzz_res;                                         \</span>
<a name="l00279"></a>00279 <span class="preprocessor">    VALGRIND_MAGIC_SEQUENCE(_qzz_res, 0,                           \</span>
<a name="l00280"></a>00280 <span class="preprocessor">                            VG_USERREQ__DISCARD_TRANSLATIONS,      \</span>
<a name="l00281"></a>00281 <span class="preprocessor">                            _qzz_addr, _qzz_len, 0, 0);            \</span>
<a name="l00282"></a>00282 <span class="preprocessor">   }</span>
<a name="l00283"></a>00283 <span class="preprocessor"></span>
<a name="l00284"></a>00284 <span class="preprocessor">#ifdef NVALGRIND</span>
<a name="l00285"></a>00285 <span class="preprocessor"></span>
<a name="l00286"></a>00286 <span class="preprocessor">#define VALGRIND_PRINTF(...)</span>
<a name="l00287"></a>00287 <span class="preprocessor"></span><span class="preprocessor">#define VALGRIND_PRINTF_BACKTRACE(...)</span>
<a name="l00288"></a>00288 <span class="preprocessor"></span>
<a name="l00289"></a>00289 <span class="preprocessor">#else </span><span class="comment">/* NVALGRIND */</span>
<a name="l00290"></a>00290 
<a name="l00291"></a>00291 <span class="keywordtype">int</span> VALGRIND_PRINTF(<span class="keyword">const</span> <span class="keywordtype">char</span> *format, ...)
<a name="l00292"></a>00292    __attribute__((format(__printf__, 1, 2)));
<a name="l00293"></a>00293 __attribute__((weak))
<a name="l00294"></a>00294 <span class="keywordtype">int</span>
<a name="l00295"></a>00295 VALGRIND_PRINTF(const <span class="keywordtype">char</span> *format, ...)
<a name="l00296"></a>00296 {
<a name="l00297"></a>00297    <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> _qzz_res;
<a name="l00298"></a>00298    va_list vargs;
<a name="l00299"></a>00299    va_start(vargs, format);
<a name="l00300"></a>00300    VALGRIND_MAGIC_SEQUENCE(_qzz_res, 0, VG_USERREQ__PRINTF,
<a name="l00301"></a>00301                            (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)format, (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)vargs, 0, 0);
<a name="l00302"></a>00302    va_end(vargs);
<a name="l00303"></a>00303    <span class="keywordflow">return</span> (<span class="keywordtype">int</span>)_qzz_res;
<a name="l00304"></a>00304 }
<a name="l00305"></a>00305 
<a name="l00306"></a>00306 <span class="keywordtype">int</span> VALGRIND_PRINTF_BACKTRACE(<span class="keyword">const</span> <span class="keywordtype">char</span> *format, ...)
<a name="l00307"></a>00307    __attribute__((format(__printf__, 1, 2)));
<a name="l00308"></a>00308 __attribute__((weak))
<a name="l00309"></a>00309 <span class="keywordtype">int</span>
<a name="l00310"></a>00310 VALGRIND_PRINTF_BACKTRACE(const <span class="keywordtype">char</span> *format, ...)
<a name="l00311"></a>00311 {
<a name="l00312"></a>00312    <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> _qzz_res;
<a name="l00313"></a>00313    va_list vargs;
<a name="l00314"></a>00314    va_start(vargs, format);
<a name="l00315"></a>00315    VALGRIND_MAGIC_SEQUENCE(_qzz_res, 0, VG_USERREQ__PRINTF_BACKTRACE,
<a name="l00316"></a>00316                            (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)format, (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)vargs, 0, 0);
<a name="l00317"></a>00317    va_end(vargs);
<a name="l00318"></a>00318    <span class="keywordflow">return</span> (<span class="keywordtype">int</span>)_qzz_res;
<a name="l00319"></a>00319 }
<a name="l00320"></a>00320 
<a name="l00321"></a>00321 <span class="preprocessor">#endif </span><span class="comment">/* NVALGRIND */</span>
<a name="l00322"></a>00322 
<a name="l00323"></a>00323 <span class="comment">/* These requests allow control to move from the simulated CPU to the</span>
<a name="l00324"></a>00324 <span class="comment">   real CPU, calling an arbitary function */</span>
<a name="l00325"></a>00325 <span class="preprocessor">#define VALGRIND_NON_SIMD_CALL0(_qyy_fn)                       \</span>
<a name="l00326"></a>00326 <span class="preprocessor">   ({unsigned long _qyy_res;                                   \</span>
<a name="l00327"></a>00327 <span class="preprocessor">    VALGRIND_MAGIC_SEQUENCE(_qyy_res, 0 </span><span class="comment">/* default return */</span>,  \
<a name="l00328"></a>00328                             VG_USERREQ__CLIENT_CALL0,          \
<a name="l00329"></a>00329                             _qyy_fn,                           \
<a name="l00330"></a>00330                             0, 0, 0);                          \
<a name="l00331"></a>00331     _qyy_res;                                                  \
<a name="l00332"></a>00332    })
<a name="l00333"></a>00333 
<a name="l00334"></a>00334 <span class="preprocessor">#define VALGRIND_NON_SIMD_CALL1(_qyy_fn, _qyy_arg1)            \</span>
<a name="l00335"></a>00335 <span class="preprocessor">   ({unsigned long _qyy_res;                                   \</span>
<a name="l00336"></a>00336 <span class="preprocessor">    VALGRIND_MAGIC_SEQUENCE(_qyy_res, 0 </span><span class="comment">/* default return */</span>,  \
<a name="l00337"></a>00337                             VG_USERREQ__CLIENT_CALL1,          \
<a name="l00338"></a>00338                             _qyy_fn,                           \
<a name="l00339"></a>00339                             _qyy_arg1, 0, 0);                  \
<a name="l00340"></a>00340     _qyy_res;                                                  \
<a name="l00341"></a>00341    })
<a name="l00342"></a>00342 
<a name="l00343"></a>00343 <span class="preprocessor">#define VALGRIND_NON_SIMD_CALL2(_qyy_fn, _qyy_arg1, _qyy_arg2) \</span>
<a name="l00344"></a>00344 <span class="preprocessor">   ({unsigned long _qyy_res;                                   \</span>
<a name="l00345"></a>00345 <span class="preprocessor">    VALGRIND_MAGIC_SEQUENCE(_qyy_res, 0 </span><span class="comment">/* default return */</span>,  \
<a name="l00346"></a>00346                             VG_USERREQ__CLIENT_CALL2,          \
<a name="l00347"></a>00347                             _qyy_fn,                           \
<a name="l00348"></a>00348                             _qyy_arg1, _qyy_arg2, 0);          \
<a name="l00349"></a>00349     _qyy_res;                                                  \
<a name="l00350"></a>00350    })
<a name="l00351"></a>00351 
<a name="l00352"></a>00352 <span class="preprocessor">#define VALGRIND_NON_SIMD_CALL3(_qyy_fn, _qyy_arg1, _qyy_arg2, _qyy_arg3)  \</span>
<a name="l00353"></a>00353 <span class="preprocessor">   ({unsigned long _qyy_res;                                         \</span>
<a name="l00354"></a>00354 <span class="preprocessor">    VALGRIND_MAGIC_SEQUENCE(_qyy_res, 0 </span><span class="comment">/* default return */</span>,        \
<a name="l00355"></a>00355                             VG_USERREQ__CLIENT_CALL3,                \
<a name="l00356"></a>00356                             _qyy_fn,                                 \
<a name="l00357"></a>00357                             _qyy_arg1, _qyy_arg2, _qyy_arg3);        \
<a name="l00358"></a>00358     _qyy_res;                                                        \
<a name="l00359"></a>00359    })
<a name="l00360"></a>00360 
<a name="l00361"></a>00361 
<a name="l00362"></a>00362 <span class="comment">/* Counts the number of errors that have been recorded by a tool.  Nb:</span>
<a name="l00363"></a>00363 <span class="comment">   the tool must record the errors with VG_(maybe_record_error)() or</span>
<a name="l00364"></a>00364 <span class="comment">   VG_(unique_error)() for them to be counted. */</span>
<a name="l00365"></a>00365 <span class="preprocessor">#define VALGRIND_COUNT_ERRORS                                           \</span>
<a name="l00366"></a>00366 <span class="preprocessor">   ({unsigned int _qyy_res;                                             \</span>
<a name="l00367"></a>00367 <span class="preprocessor">    VALGRIND_MAGIC_SEQUENCE(_qyy_res, 0 </span><span class="comment">/* default return */</span>,           \
<a name="l00368"></a>00368                             VG_USERREQ__COUNT_ERRORS,                   \
<a name="l00369"></a>00369                             0, 0, 0, 0);                                \
<a name="l00370"></a>00370     _qyy_res;                                                           \
<a name="l00371"></a>00371    })
<a name="l00372"></a>00372 
<a name="l00373"></a>00373 <span class="comment">/* Mark a block of memory as having been allocated by a malloc()-like</span>
<a name="l00374"></a>00374 <span class="comment">   function.  `addr' is the start of the usable block (ie. after any</span>
<a name="l00375"></a>00375 <span class="comment">   redzone) `rzB' is redzone size if the allocator can apply redzones;</span>
<a name="l00376"></a>00376 <span class="comment">   use '0' if not.  Adding redzones makes it more likely Valgrind will spot</span>
<a name="l00377"></a>00377 <span class="comment">   block overruns.  `is_zeroed' indicates if the memory is zeroed, as it is</span>
<a name="l00378"></a>00378 <span class="comment">   for calloc().  Put it immediately after the point where a block is</span>
<a name="l00379"></a>00379 <span class="comment">   allocated. </span>
<a name="l00380"></a>00380 <span class="comment">   </span>
<a name="l00381"></a>00381 <span class="comment">   If you're allocating memory via superblocks, and then handing out small</span>
<a name="l00382"></a>00382 <span class="comment">   chunks of each superblock, if you don't have redzones on your small</span>
<a name="l00383"></a>00383 <span class="comment">   blocks, it's worth marking the superblock with VALGRIND_MAKE_NOACCESS</span>
<a name="l00384"></a>00384 <span class="comment">   when it's created, so that block overruns are detected.  But if you can</span>
<a name="l00385"></a>00385 <span class="comment">   put redzones on, it's probably better to not do this, so that messages</span>
<a name="l00386"></a>00386 <span class="comment">   for small overruns are described in terms of the small block rather than</span>
<a name="l00387"></a>00387 <span class="comment">   the superblock (but if you have a big overrun that skips over a redzone,</span>
<a name="l00388"></a>00388 <span class="comment">   you could miss an error this way).  See memcheck/tests/custom_alloc.c</span>
<a name="l00389"></a>00389 <span class="comment">   for an example.</span>
<a name="l00390"></a>00390 <span class="comment"></span>
<a name="l00391"></a>00391 <span class="comment">   Nb: block must be freed via a free()-like function specified</span>
<a name="l00392"></a>00392 <span class="comment">   with VALGRIND_FREELIKE_BLOCK or mismatch errors will occur. */</span>
<a name="l00393"></a>00393 <span class="preprocessor">#define VALGRIND_MALLOCLIKE_BLOCK(addr, sizeB, rzB, is_zeroed)     \</span>
<a name="l00394"></a>00394 <span class="preprocessor">   {unsigned int _qzz_res;                                         \</span>
<a name="l00395"></a>00395 <span class="preprocessor">    VALGRIND_MAGIC_SEQUENCE(_qzz_res, 0,                           \</span>
<a name="l00396"></a>00396 <span class="preprocessor">                            VG_USERREQ__MALLOCLIKE_BLOCK,          \</span>
<a name="l00397"></a>00397 <span class="preprocessor">                            addr, sizeB, rzB, is_zeroed);          \</span>
<a name="l00398"></a>00398 <span class="preprocessor">   }</span>
<a name="l00399"></a>00399 <span class="preprocessor"></span>
<a name="l00400"></a>00400 <span class="comment">/* Mark a block of memory as having been freed by a free()-like function.</span>
<a name="l00401"></a>00401 <span class="comment">   `rzB' is redzone size;  it must match that given to</span>
<a name="l00402"></a>00402 <span class="comment">   VALGRIND_MALLOCLIKE_BLOCK.  Memory not freed will be detected by the leak</span>
<a name="l00403"></a>00403 <span class="comment">   checker.  Put it immediately after the point where the block is freed. */</span>
<a name="l00404"></a>00404 <span class="preprocessor">#define VALGRIND_FREELIKE_BLOCK(addr, rzB)                         \</span>
<a name="l00405"></a>00405 <span class="preprocessor">   {unsigned int _qzz_res;                                         \</span>
<a name="l00406"></a>00406 <span class="preprocessor">    VALGRIND_MAGIC_SEQUENCE(_qzz_res, 0,                           \</span>
<a name="l00407"></a>00407 <span class="preprocessor">                            VG_USERREQ__FREELIKE_BLOCK,            \</span>
<a name="l00408"></a>00408 <span class="preprocessor">                            addr, rzB, 0, 0);                      \</span>
<a name="l00409"></a>00409 <span class="preprocessor">   }</span>
<a name="l00410"></a>00410 <span class="preprocessor"></span>
<a name="l00411"></a>00411 <span class="comment">/* Create a memory pool. */</span>
<a name="l00412"></a>00412 <span class="preprocessor">#define VALGRIND_CREATE_MEMPOOL(pool, rzB, is_zeroed)              \</span>
<a name="l00413"></a>00413 <span class="preprocessor">   {unsigned int _qzz_res;                                         \</span>
<a name="l00414"></a>00414 <span class="preprocessor">    VALGRIND_MAGIC_SEQUENCE(_qzz_res, 0,                           \</span>
<a name="l00415"></a>00415 <span class="preprocessor">                            VG_USERREQ__CREATE_MEMPOOL,            \</span>
<a name="l00416"></a>00416 <span class="preprocessor">                            pool, rzB, is_zeroed, 0);              \</span>
<a name="l00417"></a>00417 <span class="preprocessor">   }</span>
<a name="l00418"></a>00418 <span class="preprocessor"></span>
<a name="l00419"></a>00419 <span class="comment">/* Destroy a memory pool. */</span>
<a name="l00420"></a>00420 <span class="preprocessor">#define VALGRIND_DESTROY_MEMPOOL(pool)                             \</span>
<a name="l00421"></a>00421 <span class="preprocessor">   {unsigned int _qzz_res;                                         \</span>
<a name="l00422"></a>00422 <span class="preprocessor">    VALGRIND_MAGIC_SEQUENCE(_qzz_res, 0,                           \</span>
<a name="l00423"></a>00423 <span class="preprocessor">                            VG_USERREQ__DESTROY_MEMPOOL,           \</span>
<a name="l00424"></a>00424 <span class="preprocessor">                            pool, 0, 0, 0);                        \</span>
<a name="l00425"></a>00425 <span class="preprocessor">   }</span>
<a name="l00426"></a>00426 <span class="preprocessor"></span>
<a name="l00427"></a>00427 <span class="comment">/* Associate a piece of memory with a memory pool. */</span>
<a name="l00428"></a>00428 <span class="preprocessor">#define VALGRIND_MEMPOOL_ALLOC(pool, addr, size)                   \</span>
<a name="l00429"></a>00429 <span class="preprocessor">   {unsigned int _qzz_res;                                         \</span>
<a name="l00430"></a>00430 <span class="preprocessor">    VALGRIND_MAGIC_SEQUENCE(_qzz_res, 0,                           \</span>
<a name="l00431"></a>00431 <span class="preprocessor">                            VG_USERREQ__MEMPOOL_ALLOC,             \</span>
<a name="l00432"></a>00432 <span class="preprocessor">                            pool, addr, size, 0);                  \</span>
<a name="l00433"></a>00433 <span class="preprocessor">   }</span>
<a name="l00434"></a>00434 <span class="preprocessor"></span>
<a name="l00435"></a>00435 <span class="comment">/* Disassociate a piece of memory from a memory pool. */</span>
<a name="l00436"></a>00436 <span class="preprocessor">#define VALGRIND_MEMPOOL_FREE(pool, addr)                          \</span>
<a name="l00437"></a>00437 <span class="preprocessor">   {unsigned int _qzz_res;                                         \</span>
<a name="l00438"></a>00438 <span class="preprocessor">    VALGRIND_MAGIC_SEQUENCE(_qzz_res, 0,                           \</span>
<a name="l00439"></a>00439 <span class="preprocessor">                            VG_USERREQ__MEMPOOL_FREE,              \</span>
<a name="l00440"></a>00440 <span class="preprocessor">                            pool, addr, 0, 0);                     \</span>
<a name="l00441"></a>00441 <span class="preprocessor">   }</span>
<a name="l00442"></a>00442 <span class="preprocessor"></span>
<a name="l00443"></a>00443 <span class="comment">/* Mark a piece of memory as being a stack. Returns a stack id. */</span>
<a name="l00444"></a>00444 <span class="preprocessor">#define VALGRIND_STACK_REGISTER(start, end)                        \</span>
<a name="l00445"></a>00445 <span class="preprocessor">   ({unsigned int _qzz_res;                                        \</span>
<a name="l00446"></a>00446 <span class="preprocessor">    VALGRIND_MAGIC_SEQUENCE(_qzz_res, 0,                           \</span>
<a name="l00447"></a>00447 <span class="preprocessor">                            VG_USERREQ__STACK_REGISTER,            \</span>
<a name="l00448"></a>00448 <span class="preprocessor">                            start, end, 0, 0);                     \</span>
<a name="l00449"></a>00449 <span class="preprocessor">    _qzz_res;                                                      \</span>
<a name="l00450"></a>00450 <span class="preprocessor">   })</span>
<a name="l00451"></a>00451 <span class="preprocessor"></span>
<a name="l00452"></a>00452 <span class="comment">/* Unmark the piece of memory associated with a stack id as being a</span>
<a name="l00453"></a>00453 <span class="comment">   stack. */</span>
<a name="l00454"></a>00454 <span class="preprocessor">#define VALGRIND_STACK_DEREGISTER(id)                              \</span>
<a name="l00455"></a>00455 <span class="preprocessor">   {unsigned int _qzz_res;                                         \</span>
<a name="l00456"></a>00456 <span class="preprocessor">    VALGRIND_MAGIC_SEQUENCE(_qzz_res, 0,                           \</span>
<a name="l00457"></a>00457 <span class="preprocessor">                            VG_USERREQ__STACK_DEREGISTER,          \</span>
<a name="l00458"></a>00458 <span class="preprocessor">                            id, 0, 0, 0);                          \</span>
<a name="l00459"></a>00459 <span class="preprocessor">   }</span>
<a name="l00460"></a>00460 <span class="preprocessor"></span>
<a name="l00461"></a>00461 <span class="comment">/* Change the start and end address of the stack id. */</span>
<a name="l00462"></a>00462 <span class="preprocessor">#define VALGRIND_STACK_CHANGE(id, start, end)                      \</span>
<a name="l00463"></a>00463 <span class="preprocessor">   {unsigned int _qzz_res;                                         \</span>
<a name="l00464"></a>00464 <span class="preprocessor">    VALGRIND_MAGIC_SEQUENCE(_qzz_res, 0,                           \</span>
<a name="l00465"></a>00465 <span class="preprocessor">                            VG_USERREQ__STACK_CHANGE,              \</span>
<a name="l00466"></a>00466 <span class="preprocessor">                            id, start, end, 0);                    \</span>
<a name="l00467"></a>00467 <span class="preprocessor">   }</span>
<a name="l00468"></a>00468 <span class="preprocessor"></span>
<a name="l00469"></a>00469 <span class="preprocessor">#endif   </span><span class="comment">/* __VALGRIND_H */</span>
</pre></div></div>
<hr size="1"><address style="text-align: right;"><small>Generated on Sat Jul 18 21:16:55 2009 for lighttpd-cpp by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.8 </small></address>
</body>
</html>
